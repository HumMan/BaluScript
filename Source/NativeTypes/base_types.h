//this code is autogenerated by http://tomeko.net/online_tools/cpp_text_escape.php?lang=en
//from file base_types_source.bscript

const char* base_types =
"\tclass int\n"
"\t{\n"
"\tprivate:\n"
"\t\tdword unnamed;\n"
"\tpublic:\n"
"\t\tcopy(float v) bytecode{ASM_FLOAT_TO_INT;ASM_INT_CONSTR;};\n"
"\n"
"\t\toperator static +=(int& l,int r)bytecode{ASM_INT_PLUS_A;};\n"
"\t\toperator static -=(int& l,int r)bytecode{ASM_INT_MINUS_A;};\n"
"\t\toperator static *=(int& l,int r)bytecode{ASM_INT_MUL_A;};\n"
"\t\toperator static /=(int& l,int r)bytecode{ASM_INT_DIV_A;};\n"
"\t\toperator static %=(int& l,int r)bytecode{ASM_INT_MOD_A;};\n"
"\n"
"\t\toperator static +(int l,int r):int bytecode{ASM_INT_PLUS;};\n"
"\t\toperator static -(int l,int r):int bytecode{ASM_INT_MINUS;};\n"
"\t\toperator static *(int l,int r):int bytecode{ASM_INT_MUL;};\n"
"\t\toperator static /(int l,int r):int bytecode{ASM_INT_DIV;};\n"
"\t\toperator static %(int l,int r):int bytecode{ASM_INT_MOD;};\n"
"\n"
"\t\toperator static -(int  l):int bytecode{ASM_INT_UNARY_MINUS;};\n"
"\t\toperator static -(int& l):int bytecode{ASM_R_INT_UNARY_MINUS;};\n"
"\n"
"\t\toperator static --(int& l) bytecode{ASM_INT_PREFIX_DEC;};\n"
"\t\toperator static ++(int& l) bytecode{ASM_INT_PREFIX_INC;};\n"
"\n"
"\t\toperator static < (int l,int r):bool bytecode{ASM_INT_LESS;};\n"
"\t\toperator static <=(int l,int r):bool bytecode{ASM_INT_LESS_EQ;};\n"
"\t\toperator static ==(int l,int r):bool bytecode{ASM_EQUAL;};\n"
"\t\toperator static !=(int l,int r):bool bytecode{ASM_NOT_EQUAL;};\n"
"\t\toperator static > (int l,int r):bool bytecode{ASM_INT_GREATER;};\n"
"\t\toperator static >=(int l,int r):bool bytecode{ASM_INT_GREATER_EQ;};\n"
"\n"
"\t\tconversion static (int& v):float bytecode{ASM_R_INT_TO_FLOAT;};\n"
"\t\tconversion static (int  v):float bytecode{ASM_INT_TO_FLOAT;};\n"
"\t\tconversion static (int& v):bool  bytecode{ASM_R_INT_TO_BOOL;};\n"
"\t\tconversion static (int  v):bool  bytecode{ASM_INT_TO_BOOL;};\n"
"\t\tconversion static (int  v):vec2  bytecode{ASM_INT_TO_VEC2;};\n"
"\t\tconversion static (int  v):vec2i  bytecode{ASM_INT_TO_VEC2I;};\n"
"\t}\n"
"\tfunc static Abs(int v\t\t):int bytecode{ASM_INT_ABS;};\n"
"\tfunc static Max(int v0,int v1):int bytecode{ASM_INT_MAXIMUM;};\n"
"\tfunc static Min(int v0,int v1):int bytecode{ASM_INT_MINIMUM;};\n"
"\tfunc static Sign(int v\t\t):int bytecode{ASM_INT_SIGN;};\n"
"\n"
"\tclass float\n"
"\t{\n"
"\tprivate:\n"
"\t\tdword unnamed;\n"
"\tpublic:\n"
"\t\tcopy(float v) bytecode{ASM_FLOAT_CONSTR;};\n"
"\n"
"\t\toperator static +=(float& l,float r)bytecode{ASM_FLOAT_PLUS_A;};\n"
"\t\toperator static -=(float& l,float r)bytecode{ASM_FLOAT_MINUS_A;};\n"
"\t\toperator static *=(float& l,float r)bytecode{ASM_FLOAT_MUL_A;};\n"
"\t\toperator static /=(float& l,float r)bytecode{ASM_FLOAT_DIV_A;};\n"
"\n"
"\t\toperator static +(float l,float r):float bytecode{ASM_FLOAT_PLUS;};\n"
"\t\toperator static -(float l,float r):float bytecode{ASM_FLOAT_MINUS;};\n"
"\t\toperator static *(float l,float r):float bytecode{ASM_FLOAT_MULT;};\n"
"\t\toperator static /(float l,float r):float bytecode{ASM_FLOAT_DIV;};\n"
"\n"
"\t\toperator static -(float  l):float bytecode{ASM_FLOAT_UNARY_MINUS;};\n"
"\t\toperator static -(float& l):float bytecode{ASM_R_FLOAT_UNARY_MINUS;};\n"
"\n"
"\t\toperator static < (float l,float r):bool bytecode{ASM_FLOAT_LESS;};\n"
"\t\toperator static <=(float l,float r):bool bytecode{ASM_FLOAT_LESS_EQ;};\n"
"\t\toperator static ==(float l,float r):bool bytecode{ASM_EQUAL;};\n"
"\t\toperator static !=(float l,float r):bool bytecode{ASM_NOT_EQUAL;};\n"
"\t\toperator static > (float l,float r):bool bytecode{ASM_FLOAT_GREATER;};\n"
"\t\toperator static >=(float l,float r):bool bytecode{ASM_FLOAT_GREATER_EQ;};\n"
"\n"
"\t\tconversion static (float& v):bool  bytecode{ASM_R_FLOAT_TO_BOOL;};\n"
"\t\tconversion static (float  v):bool  bytecode{ASM_FLOAT_TO_BOOL;};\n"
"\t\tconversion static (float  v):vec2  bytecode{ASM_FLOAT_TO_VEC2;};\n"
"\t\tconversion static (float  v):vec2i  bytecode{ASM_FLOAT_TO_VEC2I;};\n"
"\t}\n"
"\tfunc static Abs\t\t(float v):float bytecode{ASM_FLOAT_ABS;};\n"
"\tfunc static Asin\t(float v):float bytecode{ASM_FLOAT_ASIN;};\n"
"\tfunc static Acos\t(float v):float bytecode{ASM_FLOAT_ACOS;};\n"
"\tfunc static Atan\t(float v):float bytecode{ASM_FLOAT_ATAN;};\n"
"\tfunc static Ceil\t(float v):float bytecode{ASM_FLOAT_CEIL;};\n"
"\tfunc static Clamp\t(float min,float max,float v):float bytecode{ASM_FLOAT_CLAMP;};\n"
"\tfunc static Cos\t\t(float v):float bytecode{ASM_FLOAT_COS;};\n"
"\tfunc static DegToRad(float v):float bytecode{ASM_FLOAT_DEG_TO_RAD;};\n"
"\tfunc static Exp\t\t(float v):float bytecode{ASM_FLOAT_EXP;};\n"
"\tfunc static Floor\t(float v):float bytecode{ASM_FLOAT_FLOOR;};\n"
"\tfunc static Frac\t(float v):float bytecode{ASM_FLOAT_FRAC;};\n"
"\tfunc static Log\t\t(float v):float bytecode{ASM_FLOAT_LOG;};\n"
"\tfunc static Log2\t(float v):float bytecode{ASM_FLOAT_LOG2;};\n"
"\tfunc static Log10\t(float v):float bytecode{ASM_FLOAT_LOG10;};\n"
"\tfunc static Max\t\t(float v0,float v1):float bytecode{ASM_FLOAT_MAX;};\n"
"\tfunc static Min\t\t(float v0,float v1):float bytecode{ASM_FLOAT_MIN;};\n"
"\tfunc static Pi\t\t:float bytecode{ASM_FLOAT_PI;};\n"
"\tfunc static Pow\t\t(float v,float pow):float bytecode{ASM_FLOAT_POW;};\n"
"\tfunc static RadToDeg(float v):float bytecode{ASM_FLOAT_RAD_TO_DEG;};\n"
"\tfunc static Randf():float bytecode{ASM_FLOAT_RAND;};\n"
"\tfunc static Sign\t(float v):float bytecode{ASM_FLOAT_SIGN;};\n"
"\tfunc static Sin\t\t(float v):float bytecode{ASM_FLOAT_SIN;};\n"
"\tfunc static Sqrt\t(float v):float bytecode{ASM_FLOAT_SQRT;};\n"
"\tfunc static Sqr\t\t(float v):float bytecode{ASM_FLOAT_SQR;};\n"
"\tfunc static Tan\t\t(float v):float bytecode{ASM_FLOAT_TAN;};\n"
"\tfunc static Trunc\t(float v):float bytecode{ASM_FLOAT_TRUNC;};\n"
"\n"
"\tfunc static Print\t(float v) bytecode{ASM_FLOAT_PRINT;};\n"
"\n"
"\tclass bool\n"
"\t{\n"
"\tprivate:\n"
"\t\tdword unnamed;\n"
"\tpublic:\n"
"\t\tcopy(bool v) bytecode{ASM_BOOL_CONSTR;};\n"
"\n"
"\t\toperator static ==(bool l,bool r):bool bytecode{ASM_EQUAL;};\n"
"\t\toperator static !=(bool l,bool r):bool bytecode{ASM_NOT_EQUAL;};\n"
"\t\toperator static &&(bool l,bool r):bool bytecode{ASM_BOOL_AND;};\n"
"\t\toperator static ||(bool l,bool r):bool bytecode{ASM_BOOL_OR;};\n"
"\t\toperator static ! (bool l):bool bytecode{ASM_BOOL_NOT;};\n"
"\n"
"\t\tconversion static (bool& v):float bytecode{ASM_R_INT_TO_FLOAT;};\n"
"\t\tconversion static (bool  v):float bytecode{ASM_INT_TO_FLOAT;};\n"
"\t\tconversion static (bool  v):int bytecode{};\n"
"\t}\n"
"\tclass vec2\n"
"\t{\n"
"\tpublic:\n"
"\t\tfloat x,y;\n"
"\t\tcopy(float x, float y) bytecode{ASM_VEC2_CONSTR;};\n"
"\t\tcopy(vec2 v) bytecode{ASM_VEC2_CONSTR;};\n"
"\t\tcopy(int v) bytecode{ASM_INT_TO_VEC2;ASM_VEC2_CONSTR;};\n"
"\t\tcopy(float v) bytecode{ASM_FLOAT_TO_VEC2;ASM_VEC2_CONSTR;};\n"
"\t\t\n"
" \t\toperator static +=(vec2& l,vec2 r)bytecode{ASM_VEC2_PLUS_A;};\n"
"\t\toperator static -=(vec2& l,vec2 r)bytecode{ASM_VEC2_MINUS_A;};\n"
"\t\toperator static *=(vec2& l,vec2 r)bytecode{ASM_VEC2_MUL_A;};\n"
"\t\toperator static /=(vec2& l,vec2 r)bytecode{ASM_VEC2_DIV_A;};\n"
"\n"
"\t\toperator static +(vec2 l,vec2 r):vec2 bytecode{ASM_VEC2_PLUS;};\n"
"\t\toperator static -(vec2 l,vec2 r):vec2 bytecode{ASM_VEC2_MINUS;};\n"
"\t\toperator static *(vec2 l,vec2 r):vec2 bytecode{ASM_VEC2_MULT;};\n"
"\t\toperator static /(vec2 l,vec2 r):vec2 bytecode{ASM_VEC2_DIV;};\n"
"\n"
"\t\toperator static -(vec2  l):vec2 bytecode{ASM_VEC2_UNARY_MINUS;};\n"
"\t\toperator static -(vec2& l):vec2 bytecode{ASM_R_VEC2_UNARY_MINUS;};\n"
"\t\toperator static [](vec2& v,int id):float bytecode{ASM_RV_VEC2_GET_ELEMENT;};\n"
"\t\toperator static [](vec2 v,int id):float bytecode{ASM_VV_VEC2_GET_ELEMENT;};\n"
"\t}\n"
"\tfunc static Distance(vec2 v0,vec2 v1):float bytecode{ASM_VEC2_DISTANCE;};\n"
"\tfunc static Dot\t\t(vec2 v0,vec2 v1):float bytecode{ASM_VEC2_DOT;};\n"
"\tfunc static Length\t(vec2 v0):float bytecode{ASM_VEC2_LENGTH;};\n"
"\tfunc static Normalize(vec2 v0):float bytecode{ASM_VEC2_NORMALIZE;};\n"
"\tfunc static Reflect\t (vec2 v0,vec2 v1):float bytecode{ASM_VEC2_REFLECT;};\n"
"\t\n"
"\tclass vec2i\n"
"\t{\n"
"\tpublic:\n"
"\t\tint x,y;\n"
"\t\tcopy(int x, int y) bytecode{ASM_VEC2I_CONSTR;};\n"
"\t\tcopy(vec2i v) bytecode{ASM_VEC2I_CONSTR;};\n"
"\t\tcopy(int v) bytecode{ASM_INT_TO_VEC2I;ASM_VEC2I_CONSTR;};\n"
"\t\tcopy(float v) bytecode{ASM_FLOAT_TO_VEC2I;ASM_VEC2I_CONSTR;};\n"
"\t\t\n"
" \t\toperator static +=(vec2i& l,vec2i r)bytecode{ASM_VEC2I_PLUS_A;};\n"
"\t\toperator static -=(vec2i& l,vec2i r)bytecode{ASM_VEC2I_MINUS_A;};\n"
"\t\toperator static *=(vec2i& l,vec2i r)bytecode{ASM_VEC2I_MUL_A;};\n"
"\t\toperator static /=(vec2i& l,vec2i r)bytecode{ASM_VEC2I_DIV_A;};\n"
"\n"
"\t\toperator static +(vec2i l,vec2i r):vec2i bytecode{ASM_VEC2I_PLUS;};\n"
"\t\toperator static -(vec2i l,vec2i r):vec2i bytecode{ASM_VEC2I_MINUS;};\n"
"\t\toperator static *(vec2i l,vec2i r):vec2i bytecode{ASM_VEC2I_MULT;};\n"
"\t\toperator static /(vec2i l,vec2i r):vec2i bytecode{ASM_VEC2I_DIV;};\n"
"\n"
"\t\toperator static -(vec2i  l):vec2i bytecode{ASM_VEC2I_UNARY_MINUS;};\n"
"\t\toperator static -(vec2i& l):vec2i bytecode{ASM_R_VEC2I_UNARY_MINUS;};\n"
"\t\toperator static [](vec2i& v,int id):int bytecode{ASM_RV_VEC2I_GET_ELEMENT;};\n"
"\t\toperator static [](vec2i v,int id):int bytecode{ASM_VV_VEC2I_GET_ELEMENT;};\n"
"\t}\n"
"\t\n"
"\tclass char\n"
"\t{\n"
"\tprivate:\n"
"\t\tdword unnamed;\n"
"\tpublic:\n"
"\t\toperator static ==(char l,char r):bool bytecode{ASM_EQUAL;};\n"
"\t\toperator static !=(char l,char r):bool bytecode{ASM_NOT_EQUAL;};\n"
"\t}"
;